===============================
Legato Python Programming Guide
===============================

***************
Basic Usage
***************

Simply add a ``pythonPackage`` section to your cdef, and add a Python module (script with a filename ending in ``.py``) or a package (directory containing an ``__init__.py`` file). Then, bind APIs like usual.

See the ``apps/sample/pythonSample/helloInfo/`` component for a simple example.

There is no ``COMPONENT_INIT`` equivalent, as the entire script is executed when the component initializes.



*******
Results
*******

API Calls return a ``namedtuple``, which can either be unpacked (e.g. ``res, imei = le_info.GetImei()``) or referenced directly (``le_info.GetDeviceModel().model``).

When unpacking, the ``Result`` comes first, then any ``[out]`` parameters.

On the topic of ``Result``, the constant definitions in :class:`liblegato`, and the enums :class:`liblegato.Result` and ``le_XYZ.Result`` are all equivalent. In other words,

.. code-block:: python

  liblegato.LE_OK == liblegato.Result.LE_OK == le_info.Result.LE_OK

The first one is a constant from C, and the latter two are IntEnum members. They are all comparable and can be used interchangeably.



*********************
Signatures
*********************

For the most part, signatures are identical to their C counterparts.

However, if the C function operates on an existing string buffer (i.e. if the API has an ``[out]`` string parameter), there's an additional parameter that you can optionally set.

For example, let's look at the ``le_appInfo.GetName()`` function.

In C, it has this signature:

.. code-block:: c

  le_result_t le_appInfo_GetName
  (
  int32_t 	pid,
  char * 	appName,
  size_t 	appNameSize
  )

In Python, it becomes:

.. code-block:: python

   le_appInfo.GetName(pid, appName=None) -> (result: Result, appName: str)

If you call the function without providing ``appName``, an empty buffer of size ``256`` is created for you. Otherwise in the rare case where it's necessary, you may pass either a string into ``appName`` to be passed as the buffer, or an integer to change the size of the automatically allocated buffer.

Remember that Python strings aren't mutable, so if you pass a string it won't be modified. Instead, a new string will be created from the modified buffer and included in the returned namedtuple.

Normally, however, if the API function doesn't return an excessively large string , you can simply call it like ``result, app_name = le_appInfo.GetName(1337)``.

*********
Callbacks
*********

API Handlers
------------------

See the ``apps/sample/pythonSample/appInstComp/`` component for an example.

If the C handler typedef is named ``le_instStat_AppInstallEventHandler``, the Python decorator will be look like ``@le_instStat.app_install_event_handler()``. You can also provide a context as an argument to the decorator, which will then be passed to your function as the argument ``context``.

Simply mark a function definition with that decorator and the handler will be registered when the function is defined (or deferred until the service connects, if it is not connected at the time of definition).

You can also manually register handlers (as is done in LeTP) by using functions like ``le_instStat.AddAppInstallHandler(func, context=None)``, which is what the decorator does behind the scenes.

liblegato Handlers
------------------

Since the liblegato wrapper is not generated by ifgen like the APIs, the syntax is less nice, necessitating the use of cffi.

As seen in ``apps/sample/pythonSample/timerComp/timer.py``, the decorator takes the C signature of the callback as an argument:

.. code-block:: python

  @liblegato.ffi.callback("void(le_timer_Ref_t)")
  def tick(tref):
      # ...

Here is the original C signature taken from the docs:

.. code-block:: c

  typedef void(* le_timer_ExpiryHandler_t) (
  le_timer_Ref_t timerRef
  )

As you can see, the return and argument types are all that is needed for the decorator.

************
How it works
************

Summary
-------

Rather than being a Python reimplementation of the IPC code, the Python API libraries call into the existing C implementations.

The ``cffi`` library is used as an interface between Python code and the native C implementations of liblegato and API interfaces. The library is required on both the host (for generating the C extension) and target (for running it).

``ifgen`` generates the necessary C definitions that ``cffi`` uses to generate a CPython Extension (.so file), and it also creates a Python wrapper (.py) that wraps all native calls in a Pythonic interface (which is what is actually imported into the app).

The end result is two files: "le_xyz_native.so" and "le_xyz.py". They are placed into the ``read-only/lib`` directory of the app.

The bindings for :class:`liblegato` are generated in a similar fashion, but ``ifgen`` cannot be used to generate a wrapper, so as mentioned, the API is less friendly. However, there's a bit of metaprogramming magic that wraps the inputs and outputs of each function at import time for type conversion.

Liblegato
-------------------

1. ``Makefile.framework`` checks if Python and the ``cffi`` packages are installed. If so, it sets the liblegato Python wrapper and extension as a target that depends on the real liblegato.

2. ``/framework/python/generate_cdefs.sh`` is called to turn clean up liblegato header files and delete implementations so ``cffi`` can parse them. Currently this is done with a Python script but ``cproto`` would be a better alternative to aim for.

3. ``/framework/python/generate_c.py`` is called to generate the C code for the extension using the output of the previous step. This is then compiled with the regular compiler.
    The output appears in ``$(LIB_DIR)/python2.7/site-packages/``.

4. ``/framework/python/liblegato.py`` (the liblegato wrapper) is copied to the same output folder.

5. Thus when the system is installed, the wrapper and native Python extension show up at ``/legato/systems/current/lib/python2.7/site-packages/`` on the target.

Python App Components
---------------------

1. When a component is marked as having Python sources as described at the top of the page, ``hasPythonSources`` is set in mkTools.

2. ``ifgen`` is called for each component's interfaces to generate a wrapper and CPython Extension source, which is compiled by ninja.

3. Python sources are copied into the app's bin directory, and the outputs of step 2 are copied into the app's lib directory.

4. For each executable defined in the ``.adef``, an executable script is generated that patches import paths, imports :class:`liblegato`, connects to all required service APIs, and finally imports (i.e. runs) all the component sources.
